/***
 *_______________#########_______________________
 *______________############_____________________
 *______________#############____________________
 *_____________##_############___________________
 *____________###__######_#####__________________
 *____________###_########__####_________________
 *___________###__##########_####________________
 *__________####__###########_####_______________
 *________#####___###########__#####_____________
 *_______######___###_########___#####___________
 *_______#####___###___########___######_________
 *______######___###__###########___######_______
 *_____######___####_##############__######______
 *____#######__#####################_#######_____
 *____#######__##############################____
 *___#######__######_#################_#######___
 *___#######__######_######_#########___######___
 *___#######____##__######___######_____######___
 *___#######________######____#####_____#####____
 *____######________#####_____#####_____####_____
 *_____#####________####______#####_____###______
 *______#####______;###________###______#________
 *________##_______####________####______________
 */
/*
 * @Author: yuange
 * @LastEditors: yuange
 * @Description: Coding everyday!
 * @Date: 2019-03-04 10:13:54
 * @LastEditTime: 2019-03-04 14:38:18
 */
// 使用普通的单调栈即可解决
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& findNums, vector<int>& nums) {
        int n1 = findNums.size(), n2 = nums.size();
		map<int, int> hash; // key和value都是值
		stack<int> st; // 单调递减栈
		for (int i = 0; i < n2;)
		{
			if (st.empty()) st.push(i++);
			else if (nums[st.top()] >= nums[i]) st.push(i++);
			else {
				// 出栈操作
				hash[nums[st.top()]] = nums[i];
				st.pop();
			}
		}
		vector<int> ans(n1, -1);
		for (int i = 0; i < n1; ++i)
            if (hash.find(findNums[i]) != hash.end()) ans[i] = hash[findNums[i]];
		return ans;
    }
};