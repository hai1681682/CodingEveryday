/***
 *_______________#########_______________________
 *______________############_____________________
 *______________#############____________________
 *_____________##_############___________________
 *____________###__######_#####__________________
 *____________###_########__####_________________
 *___________###__##########_####________________
 *__________####__###########_####_______________
 *________#####___###########__#####_____________
 *_______######___###_########___#####___________
 *_______#####___###___########___######_________
 *______######___###__###########___######_______
 *_____######___####_##############__######______
 *____#######__#####################_#######_____
 *____#######__##############################____
 *___#######__######_#################_#######___
 *___#######__######_######_#########___######___
 *___#######____##__######___######_____######___
 *___#######________######____#####_____#####____
 *____######________#####_____#####_____####_____
 *_____#####________####______#####_____###______
 *______#####______;###________###______#________
 *________##_______####________####______________
 */
/*
 * @Author: yuange
 * @LastEditors: yuange
 * @Description: Coding everyday!
 * @Date: 2019-03-22 17:10:34
 * @LastEditTime: 2019-03-22 17:10:50
 */
// partition算法，28ms，但是只有35%？
class Solution {
public:
	int findKthLargest(vector<int>& nums, int k) {
		return partition(nums, 0, nums.size() - 1, nums.size() + 1 - k);
	}

	// 可以算出第k小的数
	int partition(vector<int>& nums, int l, int r, int k) {
		int m = nums[r], ll = l, rr = r;
		while (l < r) {
			while (nums[l] < m && l < r) ++l;
			while (nums[r] >= m && l < r) --r;
			swap(nums[l], nums[r]);
		}
		swap(nums[l], nums[rr]);
		--r;
		if (l - ll + 1 > k) return partition(nums, ll, r, k);
		else if (l - ll + 1 < k) return partition(nums, l + 1, rr, k - (l - ll + 1));
		else return m;
	}
};