/***
 *_______________#########_______________________
 *______________############_____________________
 *______________#############____________________
 *_____________##_############___________________
 *____________###__######_#####__________________
 *____________###_########__####_________________
 *___________###__##########_####________________
 *__________####__###########_####_______________
 *________#####___###########__#####_____________
 *_______######___###_########___#####___________
 *_______#####___###___########___######_________
 *______######___###__###########___######_______
 *_____######___####_##############__######______
 *____#######__#####################_#######_____
 *____#######__##############################____
 *___#######__######_#################_#######___
 *___#######__######_######_#########___######___
 *___#######____##__######___######_____######___
 *___#######________######____#####_____#####____
 *____######________#####_____#####_____####_____
 *_____#####________####______#####_____###______
 *______#####______;###________###______#________
 *________##_______####________####______________
 */
/*
 * @Author: yuange
 * @LastEditors: yuange
 * @Description: Coding everyday!
 * @Date: 2019-03-18 14:10:30
 * @LastEditTime: 2019-03-18 14:33:20
 */
// 使用map能击败100%，但是空间复杂度比较高，不过也不失为一个好办法
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> mp1, mp2;
        for (auto i : nums1) {
            auto ite = mp1.find(i);
            if (ite != mp1.end()) ite->second++;
            else mp1.insert(pair<int, int>(i, 1));
        }
        for (auto i : nums2) {
            auto ite = mp2.find(i);
            if (ite != mp2.end()) ite->second++;
            else mp2.insert(pair<int, int>(i, 1));
        }
        vector<int> ret;
        for (auto it1 : mp1) {
            auto it2 = mp2.find(it1.first);
            if (it2 != mp2.end()) {
                int n = min(it1.second, it2->second);
                for (int i = 0; i < n; ++i)
                    ret.push_back(it1.first);
            }
        }
        return ret;
    }
};