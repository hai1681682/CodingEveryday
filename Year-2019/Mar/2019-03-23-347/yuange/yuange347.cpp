/***
 *_______________#########_______________________
 *______________############_____________________
 *______________#############____________________
 *_____________##_############___________________
 *____________###__######_#####__________________
 *____________###_########__####_________________
 *___________###__##########_####________________
 *__________####__###########_####_______________
 *________#####___###########__#####_____________
 *_______######___###_########___#####___________
 *_______#####___###___########___######_________
 *______######___###__###########___######_______
 *_____######___####_##############__######______
 *____#######__#####################_#######_____
 *____#######__##############################____
 *___#######__######_#################_#######___
 *___#######__######_######_#########___######___
 *___#######____##__######___######_____######___
 *___#######________######____#####_____#####____
 *____######________#####_____#####_____####_____
 *_____#####________####______#####_____###______
 *______#####______;###________###______#________
 *________##_______####________####______________
 */
/*
 * @Author: yuange
 * @LastEditors: yuange
 * @Description: Coding everyday!
 * @Date: 2019-03-25 14:52:42
 * @LastEditTime: 2019-03-25 14:54:09
 */
// 普通的map+优先队列堆排序，32ms，20%
class Solution {
private:
    typedef struct item {
        item(int v, int c) : value(v), count(c) {}
        int value = 0;
        int count = 0;
        bool operator < (const item& i) const {
            return count < i.count;
        }
    } item;
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        vector<int> ret;
        unordered_map<int, int> mp;
        priority_queue<item> pq;
        for (auto i : nums)
            if (mp.find(i) == mp.end()) mp.insert(pair<int,int>(i, 1));
            else ++mp[i];
        for (auto p : mp)
            pq.push(item(p.first, p.second));
        for (int i = 0; i < k; ++i) {
            ret.push_back(pq.top().value);
            pq.pop();
        }
        return ret;
    }
};