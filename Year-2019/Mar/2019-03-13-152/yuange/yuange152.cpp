/***
 *_______________#########_______________________
 *______________############_____________________
 *______________#############____________________
 *_____________##_############___________________
 *____________###__######_#####__________________
 *____________###_########__####_________________
 *___________###__##########_####________________
 *__________####__###########_####_______________
 *________#####___###########__#####_____________
 *_______######___###_########___#####___________
 *_______#####___###___########___######_________
 *______######___###__###########___######_______
 *_____######___####_##############__######______
 *____#######__#####################_#######_____
 *____#######__##############################____
 *___#######__######_#################_#######___
 *___#######__######_######_#########___######___
 *___#######____##__######___######_____######___
 *___#######________######____#####_____#####____
 *____######________#####_____#####_____####_____
 *_____#####________####______#####_____###______
 *______#####______;###________###______#________
 *________##_______####________####______________
 */
/*
 * @Author: yuange
 * @LastEditors: yuange
 * @Description: Coding everyday!
 * @Date: 2019-03-13 17:29:55
 * @LastEditTime: 2019-03-13 18:24:17
 */
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        // s_min:以i-1结尾的连续最小乘积，状态转移方程需要考虑负数的情况
        // s_max:以i-1结尾的连续最大乘积
        // dp:当前连续乘积最大值
        int n = nums.size();
        int dp = -0x3f3f3f;
        int s_min = 1, s_max = 1;
        for (int i = 0; i < n; ++i) {
            // 更新s_min与s_max
            int tmx = s_max, tmn = s_min;
            s_min = min(nums[i], min(tmn * nums[i], tmx * nums[i]));
            s_max = max(nums[i], max(tmn * nums[i], tmx * nums[i]));

            // 状态转移方程
            dp = max(dp, s_max);
        }
        return dp;
    }
};