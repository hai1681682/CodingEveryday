/***
 *_______________#########_______________________
 *______________############_____________________
 *______________#############____________________
 *_____________##_############___________________
 *____________###__######_#####__________________
 *____________###_########__####_________________
 *___________###__##########_####________________
 *__________####__###########_####_______________
 *________#####___###########__#####_____________
 *_______######___###_########___#####___________
 *_______#####___###___########___######_________
 *______######___###__###########___######_______
 *_____######___####_##############__######______
 *____#######__#####################_#######_____
 *____#######__##############################____
 *___#######__######_#################_#######___
 *___#######__######_######_#########___######___
 *___#######____##__######___######_____######___
 *___#######________######____#####_____#####____
 *____######________#####_____#####_____####_____
 *_____#####________####______#####_____###______
 *______#####______;###________###______#________
 *________##_______####________####______________
 */
/*
 * @Author: yuange
 * @LastEditors: yuange
 * @Description: Coding everyday!
 * @Date: 2019-03-26 17:13:18
 * @LastEditTime: 2019-03-26 17:14:23
 */
// 8说了，再过几天估计自己都看不懂了，60ms，78%
class Solution {
public:
	vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		// 利用单调栈找到数组每个元素右边第一个大于它的位置
		int n = nums.size();
		stack<int> st;
		vector<int> pos(n, -1);
		for (int i = 0; i < n;) {
			if (st.empty()) st.push(i++);
			else if (nums[st.top()] >= nums[i]) st.push(i++);
			else {
				pos[st.top()] = i;
				st.pop();
			}
		}
		// 开始滑动
		vector<int> ret;
		if (nums.empty()) return ret;
		int p = 0;
		for (int i = 0; i < k; ++i) if (nums[i] >= nums[p]) p = i;
		ret.push_back(nums[p]);
		for (int i = k; i < n; ++i) {
			if (nums[i - k] != nums[p]) p = nums[i] >= nums[p] ? i : p;
			else { // i - k 被淘汰，重新找到最大值
				if (-1 == pos[i - k + 1]) p = nums[i] >= nums[i - k + 1] ? i : i - k + 1;
				else {
					int t = i - k + 1;
					int l = t;
					while (t != -1 && pos[t] <= i) {
						l = t;
						t = pos[t];
					}
					p = t == -1 ? l : t;
				}
			}
			ret.push_back(nums[p]);
		}
		return ret;
	}
};