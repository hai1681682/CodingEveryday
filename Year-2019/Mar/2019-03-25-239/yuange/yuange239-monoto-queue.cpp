/***
 *_______________#########_______________________
 *______________############_____________________
 *______________#############____________________
 *_____________##_############___________________
 *____________###__######_#####__________________
 *____________###_########__####_________________
 *___________###__##########_####________________
 *__________####__###########_####_______________
 *________#####___###########__#####_____________
 *_______######___###_########___#####___________
 *_______#####___###___########___######_________
 *______######___###__###########___######_______
 *_____######___####_##############__######______
 *____#######__#####################_#######_____
 *____#######__##############################____
 *___#######__######_#################_#######___
 *___#######__######_######_#########___######___
 *___#######____##__######___######_____######___
 *___#######________######____#####_____#####____
 *____######________#####_____#####_____####_____
 *_____#####________####______#####_____###______
 *______#####______;###________###______#________
 *________##_______####________####______________
 */
/*
 * @Author: yuange
 * @LastEditors: yuange
 * @Description: Coding everyday!
 * @Date: 2019-03-26 17:56:50
 * @LastEditTime: 2019-03-27 10:45:44
 */
// 最好最快的思路，单调队列,56ms,98%
class Solution {
public:
	vector<int> maxSlidingWindow(vector<int>& nums, int k) {
		vector<int> ret;
		int m = 0, n = nums.size();
		for (int i = 0; i < k; ++i) if (nums[i] > nums[m]) m = i;
        	if (nums.empty()) return ret;
		ret.push_back(nums[m]);
		for (int i = k; i < n; ++i) {
			if (i - k == m) for (int j = ++m; j <= i; ++j) m = nums[j] > nums[m] ? j : m;
			else if (nums[i] > nums[m]) m = i;
			ret.push_back(nums[m]);
		}
		return ret;
	}
};
