/***
 *_______________#########_______________________
 *______________############_____________________
 *______________#############____________________
 *_____________##_############___________________
 *____________###__######_#####__________________
 *____________###_########__####_________________
 *___________###__##########_####________________
 *__________####__###########_####_______________
 *________#####___###########__#####_____________
 *_______######___###_########___#####___________
 *_______#####___###___########___######_________
 *______######___###__###########___######_______
 *_____######___####_##############__######______
 *____#######__#####################_#######_____
 *____#######__##############################____
 *___#######__######_#################_#######___
 *___#######__######_######_#########___######___
 *___#######____##__######___######_____######___
 *___#######________######____#####_____#####____
 *____######________#####_____#####_____####_____
 *_____#####________####______#####_____###______
 *______#####______;###________###______#________
 *________##_______####________####______________
 */
/*
 * @Author: yuange
 * @LastEditors: yuange
 * @Description: Coding everyday!
 * @Date: 2019-03-01 14:49:11
 * @LastEditTime: 2019-03-01 14:54:03
 */

// 01背包问题的衍生问题，取出k个数看能否满足和为sum的一半
// 使用1维数组代替2维数组可以更省空间，并用bool值代替总和可使代码更精简
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (auto item : nums) sum += item;
        if (sum % 2) return false;
        sum >>= 1;

        // 背包容量为sum，map[j]代表背包容量为j时，是否存在刚好装满的组合
        int n = nums.size();
        bool* map = new bool[sum + 1];
        memset(map, 0, sizeof(bool) * (sum + 1));
        map[0] = true;
        for (int i = 0; i < n; ++i)
        {
            for (int j = sum; j >= nums[i]; --j)
            {
                // 状态转移方程：map[i][j] = map[i][j - 1] || map[i][j - nums[i]];
                map[j] = map[j] || map[j - nums[i]];
            }
        }
        return map[sum];
    }
};